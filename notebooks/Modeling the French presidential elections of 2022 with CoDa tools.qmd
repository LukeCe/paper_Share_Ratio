---
title: "Modeling the French presidential elections of 2022 with CoDa tools"
author:
  - Lukas Dargel
  - Christine Thomas-Agnan
format:
  html:
    theme: minty
    toc: true
    number-sections: true
    code-fold: true
    code-tools: true
    df-print: kable
execute:
  cache: true
  fig-show: "hold"
---

```{r setup}
#| warning: false
#| message: false
library("compositions")
library("data.table")
library("here")
library("ggplot2")
library("ggExtra")
library("kableExtra")
library("skimr")
library("zCompositions")


options(knitr.kable.NA = '',
        scipen = 9)

mun_elec2census <- readRDS(here("out/data/mun_elec2census.Rds")) # election data combined with the census
mun_elec <- readRDS(here("in/data/mun_elec.Rds")) # original election data 
```


The vignette illustrates results of the article from Dargel and Thomas-Agnan (2023).


# Introduction

We model the french elections using CoDa tools.
This is more a demonstration of the capacity of these tools.



# Descriptive statistics

The study combine the official election results with census data.
  -
  -
  

## Data overview 

Lets have a first look at the combined dataset.

```{r}
skim(mun_elec2census)
```


## Compare losses due to preprocessing 


Lets compare the original voting data with the combined voting data to assess the losses and potential biases.

```{r}
# original election columns
elec_cols <- setdiff(names(mun_elec), c("ID_MUN", "NAME_MUN", "NAME_DEP"))
pct <- function(x) scales::percent(x,accuracy = .1)
summarize_elec <- function(dt) {
  
  dt <- data.table(
    MUN_COUNT = nrow(dt),
    DEP_COUNT = length(unique(dt$NAME_DEP)),
    dt[,lapply(.SD, sum), .SDcols = elec_cols]
  )
  
  
  dt[,EXPRESSED := NA]
  dt[,INSCRIBED := sum(.SD), .SDcols = elec_cols]
  dt[,EXPRESSED := INSCRIBED - ABSTENTIONS - BLANK - INVALID]
  
  show_dt <- data.table(t(dt),keep.rownames = TRUE)
  
  dont_use <- c("MUN_COUNT","DEP_COUNT")
  show_dt[!rn %in% dont_use,
          "% of INSCRIBED" := pct(V1/dt[["INSCRIBED"]])]
  
  dont_use <- c(dont_use, "ABSTENTIONS", "BLANK", "INVALID", "INSCRIBED")
  show_dt[!rn %in% dont_use,
          "% of EXPRESSED" := pct(V1/dt[["EXPRESSED"]])]
  names(show_dt)[1:2] <- c("INDICATOR", "COUNT")
  show_dt
}  


elec_original <- summarize_elec(mun_elec)
elec_combined <- summarize_elec(mun_elec2census)
elec_combined <- cbind(LOSS = elec_original[["COUNT"]] - elec_combined[["COUNT"]], elec_combined[,-1])
elec_combined <- cbind("% LOSS" = pct(elec_combined[["LOSS"]]/elec_combined[["COUNT"]]), elec_combined)
kable(cbind(elec_original, elec_combined)) |> 
  kable_classic(full_width = F) |> 
  add_header_above(c(" " = 1, "Full election data" = 3, "Combined election data" = 5)) |> 
  pack_rows(group_label = "Units", 1,2,hline_after = TRUE) |> 
  pack_rows(group_label = "Not expressed", 3,5,hline_after = TRUE) |> 
  pack_rows(group_label = "Expressed", 6,17,hline_after = TRUE) |> 
  pack_rows(group_label = "Totals", 18,19,hline_after = TRUE) |> 
  column_spec(1, bold = T) 
```


## Check for problems with zeros


### In the vote data

We first check for zeros in the dependent variables.

```{r}
zero_summary <- function(dt) dt[,lapply(.SD, function(x) pct(sum(x==0)/.N))]
zero_summary(mun_elec2census[,..elec_cols])
```

One way to solve the problem is amalgamations.
We see that almost $98.5\%$ of observations are complete now.

```{r}
left_bloc <- c("ARTHAUD_Nathalie", "ROUSSEL_Fabien", "HIDALGO_Anne", "JADOT_Yannick", "POUTOU_Philippe")
right_bloc <- c("ZEMMOUR_Eric", "PECRESSE_Valerie", "LASSALLE_Jean", "DUPONT_AIGNAN_Nicolas")

VOTE <- cbind(
  mun_elec2census[,c("MACRON_Emmanuel", "LE_PEN_Marine", "MELENCHON_Jean_Luc")],
  LEFT = rowSums(mun_elec2census[,..left_bloc]),
  RIGHT = rowSums(mun_elec2census[,..right_bloc]),
  NON_VOTE = rowSums(mun_elec2census[,c("ABSTENTIONS", "INVALID","BLANK"),]))

zPatterns(
  VOTE,
  label="0",
  bar.labels = c(T,T),
  axis.labels = c(NA,NA))
```

`r zv <- sum(0 != rowSums(VOTE == 0))`
The remaining zeros are imputed.
Here take the simple road of adding 1 for to all lines with at least one zero.
Here we impute data in `r zv` cases with `r zv*ncol(VOTE)` additional "inscriptions".


```{r}
is_zero_row <- 0 != rowSums(VOTE == 0) 
VOTE_IMP <- VOTE + is_zero_row
cbind(
  sum(is_zero_row),
  sum(is_zero_row) * ncol(VOTE),
  sum(VOTE_IMP) - sum(VOTE))
```

#### Before and after

Lets check the impact of the imputation on the distribution of the data.
We see that our imputation leads an increase in the variance, but does not affected the average in a noticable way.
This is expected because our imputation method replaces zeros (red bars in the graphic) with points close to the edge of the triangle, which are extreme values in the simplex sense.

```{r}
#| fig-show: "hold"

simplex_isodensity <- function(
  data,
  quantiles = c(0.5,1:9,9.5)/10,
  labels = names(cen),
  col1 = "black",
  col2 = "grey45",
  plot_data = TRUE) {
  
  # code adapted from:
  # Van den Boogaart and Tolosana-Delgado (2013), page 52
  
  stopifnot(ncol(data) == 3)
  cen <- mean(data)
  var <- var(data)
  if (plot_data) 
    plot(data, pch = ".", col = "grey85", labels = labels, mp = NULL, lenMissingTck = 0.02)
  plot(cen,pch=4, col = col1, labels = labels, add = plot_data)
  for (p in quantiles) {
    r = sqrt(qchisq(p=p,df=2))
    ellipses(cen,var,r, col=col2)
  }
}

opar <- par(mar=c(0,3,0,3), mfrow = c(1,2))
simplex_isodensity(acomp(VOTE_IMP[,1:3]), labels = c("Macron", "Le Pen", "Mélenchon"))
title(sub = "Imputed", outer = FALSE)
simplex_isodensity(acomp(VOTE[,1:3]), labels = c("Macron", "Le Pen", "Mélenchon"))
title(sub = "Original")
par(opar)
```

```{r}
#| fig-show: "hold"

opar <- par(mar=c(0,3,0,3), mfrow = c(1,2))
simplex_isodensity(acomp(VOTE_IMP[,-(1:3)]), labels = c("Left", "Right", "No vote"))
title(sub = "Imputed", outer = FALSE)
simplex_isodensity(acomp(VOTE[,-(1:3)]), labels = c("Left", "Right", "No vote"))
title(sub = "Original")
par(opar)
```



### In the professional categories (pc) data



```{r}
pc_cols <- names(mun_elec2census)
pc_cols <- pc_cols[grep("^C19_", pc_cols)]
zero_summary(mun_elec2census[,..pc_cols])
```

About $95%$ of case are complete.

```{r}
PROFCAT <- cbind(
  "PC1" = mun_elec2census[,C19_POP15P_CS3 + C19_POP15P_CS4],
  "PC2" = mun_elec2census[,C19_POP15P_CS5 + C19_POP15P_CS6],
  "PC3" = mun_elec2census[,C19_POP15P_CS7],
  "PC4" = mun_elec2census[,C19_POP15P_CS1 + C19_POP15P_CS2 + C19_POP15P_CS8]
)

zPatterns(
  PROFCAT,
  label="0",
  bar.labels = c(T,T),
  axis.labels = c(NA,NA))
```

`r zv <- sum(0 != rowSums(PROFCAT == 0))`
We impute the data using the same strateas before.
Here we impute data in `r zv` cases with `r zv*ncol(PROFCAT)` additional "inscriptions".

```{r}
is_zero_row <- 0 != rowSums(PROFCAT == 0) 
PROFCAT_IMP <- PROFCAT + is_zero_row
cbind(
  sum(is_zero_row),
  sum(is_zero_row) * ncol(PROFCAT),
  sum(PROFCAT_IMP) - sum(PROFCAT))
```

#### Before and after imputation

We have the same results as before, but the increase in variance appears more pronounced.

```{r}
#| fig-show: "hold"
opar <- par(mar=c(0,3,0,3), mfrow = c(1,2))
simplex_isodensity(acomp(PROFCAT_IMP[,(1:3)]))
title(sub = "Imputed", outer = FALSE)
simplex_isodensity(acomp(PROFCAT[,(1:3)]))
title(sub = "Original")
par(opar)
```

```{r}
#| fig-show: "hold"
opar <- par(mar=c(0,3,0,3), mfrow = c(1,2))
simplex_isodensity(acomp(PROFCAT_IMP[,(2:4)]))
title(sub = "Imputed", outer = FALSE)
simplex_isodensity(acomp(PROFCAT[,(2:4)]))
title(sub = "Original")
par(opar)
```


# Exploratory analysis


We defined the data set for our analysis.
Which is based on the imputed vote and professional categories (PC) data.


```{r}
mun2explore <- data.table(
  ID_MUN = mun_elec2census$ID_MUN,
  INSCRIBED = rowSums(VOTE_IMP))
mun2explore <- cbind(mun2explore, VOTE_IMP, PROFCAT_IMP)
```


## Concentration



## Heteroskedasticity


Since election data corresponds to aggregations of individual choices we should suspect heteroskedasticity.
The scatter plot below shows that that the share of "non votes" is directly impacted by the total number of voters.
Additionally, its volatility seems to decrease with the size of the municipality in terms number if voters.

```{r}
ggplot(mun2explore[INSCRIBED < 300000,], aes(x = sqrt(INSCRIBED), y = NON_VOTE/INSCRIBED)) +
  # geom_boxplot(aes(x = INSCRIBED_BINS, y = ABSTENTIONS/INSCRIBED)) +
  geom_point() +
  geom_smooth() +
  theme_bw() +
  theme()
```

A similar pattern is observed for all vote variables.

```{r}
seq125 <- c(0, unlist(lapply(10^seq(10), "*", c(1,2,5))))
seqSqr <- seq(0,15)^2 * 1000 
mun2explore[,INSCRIBED_BINS := cut(INSCRIBED,c(seqSqr,Inf))]
mun2explore_long <- 
  melt(mun2explore,
       id.vars = c("ID_MUN","INSCRIBED_BINS"),
       measure.vars = colnames(VOTE))

mun2explore_long[,value_rel := value/sum(value), by = "ID_MUN"]
ggplot(mun2explore_long, aes(x = INSCRIBED_BINS, y = value_rel)) +
  geom_boxplot(outlier.size = .1) +
  facet_wrap("variable", ncol = 3) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90))

```


And for the PC variables as well.

```{r}
mun2explore_long2 <- 
  melt(mun2explore,
       id.vars = c("ID_MUN","INSCRIBED_BINS"),
       measure.vars = colnames(PROFCAT))

mun2explore_long2[,value_rel := value/sum(value), by = "ID_MUN"]
ggplot(mun2explore_long2, aes(x = INSCRIBED_BINS, y = value_rel)) +
  geom_boxplot(outlier.size = .1) +
  facet_wrap("variable", ncol = 2) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90))
```


##  Correlations


# Model for the share of "non votes"

```{r}
mun2model <- data.frame(
  ID_MUN = mun_elec2census$ID_MUN,
  INSCRIBED = rowSums(as.matrix(VOTE_IMP)),
  INSCRIBED_G = Reduce("*", lapply(VOTE_IMP, as.numeric)))
mun2model[["VOTE"]] <- acomp(VOTE_IMP)
mun2model[["PROFCAT"]] <- acomp(PROFCAT_IMP)

logit <- function(p) log(p/(p+1))
NV_model <- lm(
  logit(VOTE[,6]) ~  ilr(PROFCAT) + log(INSCRIBED),
  data = mun2model,
  weights = INSCRIBED)
summary(NV_model)
```


## Coefficients and Semi-elasticites

```{r}
clr_coefs <- matrix(ilr2clr(NV_model$coefficients[2:4]),nrow = 1)
barplot(clr_coefs, names.arg = colnames(PROFCAT))
```

## Variation scenarios

Let us investigate how the model react to changes when the PC composition changes in paris.

```{r}
paris <- "75056"
paris <- mun2model[mun2model$ID_MUN == paris,,drop = FALSE]
paris$VOTE
paris$PROFCAT
```


### Changing in direction of first summit

```{r}
paris_pcseq1 <- CoDa_seq(
  comp_from = paris$PROFCAT,
  comp_to = c(1e10,1,1,1)*as.numeric(paris$PROFCAT),
  add_opposite = TRUE)

barplot(acomp(paris_pcseq1[,,drop=FALSE]))
```

This is a special direction that leaves the ratios between all other components constant.

```{r}
#| fig-show: "hold"
opar <- par(mfrow = c(1,2))
plot.acomp(paris_pcseq1[,-4])
plot.acomp(paris_pcseq1["0",-4, drop = FALSE], col = "red", add = TRUE, pch = "X")


plot.acomp(paris_pcseq1[,-1])
plot.acomp(paris_pcseq1["0",-1, drop = FALSE], col = "red", add = TRUE, pch = "X")
par(opar)
```

The changes appear linear in real space.

```{r}
paris_pcseq1_gg <- data.frame(paris_pcseq1)
colnames(paris_pcseq1_gg) <- paste0("PC", 1:4)
ggplot(paris_pcseq1_gg) +
  geom_vline(xintercept = paris$PROFCAT[[1]]) +
  geom_line(aes(x = PC1, y = PC1, col = "1", lty = "1"), lwd = .51) +
  geom_line(aes(x = PC1, y = PC2, col = "2", lty = "2"), lwd = .51) +
  geom_line(aes(x = PC1, y = PC3, col = "3", lty = "3"), lwd = .51) +
  geom_line(aes(x = PC1, y = PC4, col = "4", lty = "4"), lwd = .51) +
  geom_hline(yintercept = 0, col = "black") +
  geom_boxplot(
    data = data.frame(PC1 = mun2model$PROFCAT[,1]),
    mapping = aes(x = PC1, y = -.0625),
    varwidth = TRUE,
    size = .5,
    col = "red",
    alpha = .25,
    width = .05) +
  scale_x_continuous(labels = scales::percent) +
  scale_y_continuous(labels = scales::percent) +
  scale_color_manual(
    breaks = c("1","2", "3", "4"),
    values = c("Red", "Orange", "Dark Blue", "Yellow"),
    name = "PC") +
  scale_linetype_manual(
    breaks = c("1","2", "3", "4"),
    values = 1:4,
    name = "PC") +
  labs(x = "% PC 1", y = "% PC") +
  theme_bw()
```


### Changing in direction of the origin

An alternative linear change is the direction that connects the composition of Paris with the origin, that is the balanced composition.

```{r}
paris_pcseq2 <- CoDa_path(
  comp_direc = paris$PROFCAT,
  comp_from = paris$PROFCAT,
  add_opposite = TRUE,
  step_size = attr(paris_pcseq1,"step_size"))

barplot(acomp(paris_pcseq2[,,drop=FALSE]))
```

Here the paths in the simplex look more complex.

```{r}
#| fig-show: "hold"
opar <- par(mfrow = c(1,2))
plot.acomp(paris_pcseq2[,-4])
plot.acomp(paris_pcseq2["0",-4, drop = FALSE], col = "red", add = TRUE, pch = "X")

plot.acomp(paris_pcseq2[,-1])
plot.acomp(paris_pcseq2["0",-1, drop = FALSE], col = "red", add = TRUE, pch = "X")
par(opar)
```

Here we have non-linear changes.
We see that the lines cross in the origin and at the position of pairs their values equal as before.

```{r}

paris_pcseq2_gg <- data.frame(paris_pcseq2)
colnames(paris_pcseq2_gg) <- paste0("PC", 1:4)
ggplot(paris_pcseq2_gg) +
  geom_vline(xintercept = paris$PROFCAT[[1]]) +
  geom_vline(xintercept = 1/4, col = "grey55") +
  geom_line(aes(x = PC1, y = PC1, col = "1", lty = "1"), lwd = .51) +
  geom_line(aes(x = PC1, y = PC2, col = "2", lty = "2"), lwd = .51) +
  geom_line(aes(x = PC1, y = PC3, col = "3", lty = "3"), lwd = .51) +
  geom_line(aes(x = PC1, y = PC4, col = "4", lty = "4"), lwd = .51) +
  geom_hline(yintercept = 0, col = "black") +
  geom_boxplot(
    data = data.frame(PC1 = mun2model$PROFCAT[,1]),
    mapping = aes(x = PC1, y = -.0625),
    varwidth = TRUE,
    size = .5,
    col = "red",
    alpha = .25,
    width = .05) +
  scale_x_continuous(labels = scales::percent) +
  scale_y_continuous(labels = scales::percent) +
  scale_color_manual(
    breaks = c("1","2", "3", "4"),
    values = c("Red", "Orange", "Dark Blue", "Yellow"),
    name = "Professional\nCategory") +
  scale_linetype_manual(
    breaks = c("1","2", "3", "4"),
    values = 1:4,
    name = "Professional\nCategory") +
  labs(x = "% PC 1", y = "% PC") +
  theme_bw() +
  theme(axis.line.x = element_blank())
```


### Effects of these changes on the predicted shares

```{r}
```



### Dependence profiles for the whole dataset



# Model of the full compostion of votes

```{r}
VOTE_model <- lm(
  ilr(VOTE) ~  ilr(PROFCAT) + log(INSCRIBED),
  data = mun2model,
  weights = INSCRIBED)
summary(VOTE_model)
```


## Coefficients  and Elasticities

```{r}
clr_coefs <- (ilrBase(D = 4)) %*% as.matrix(ilr2clr(VOTE_model$coefficients[2:4,]))
colnames(clr_coefs) <- colnames(VOTE)
clr_coefs <- cbind(PROFCAT = colnames(PROFCAT), data.table(clr_coefs))
clr_coefs_gg <- melt(clr_coefs, id.var = "PROFCAT")

ggplot(clr_coefs_gg) +
  # geom_col(aes(y = value, group = variable, x = variable, fill = variable, col = variable),
  #          position = "dodge") +
  theme_bw() +
  coord_flip() +
  geom_hline(yintercept = 0) +
  geom_segment(aes(x=variable, xend=variable, y=0, yend=value, col = variable)) +
  geom_point(aes(x=variable, y = value, col = variable)) +
  geom_boxplot(aes(y = value, x = "All")) +
  facet_wrap("PROFCAT") +
  theme(legend.position = "none")

ggplot(clr_coefs_gg) +
  geom_segment(aes(x=PROFCAT, xend=PROFCAT, y=0, yend=value)) +
  geom_point(aes(x=PROFCAT, y = value)) +
  # geom_col(aes(y = value, group = variable, x = PROFCAT, fill = variable, col = variable),
           # position = "dodge") +
  geom_boxplot(aes(y = value, x = "All")) +
  theme_bw() +
  facet_wrap("variable")
```


## Vriation scenarios



## Dependence profiles










# Acknowlegements {-}

This work emerged from a Statistical Consulting project class of the Master in D3S of TSE in cooperation with he Market Research agency BVA who motivated the topic.
The project was a great experience and we want to thank all particitpants.
This includes Oliver Henebelle and Alejandro Lara who advised the project from the business.
We also thank our four students, Claire LEBRUN, Malo Bert, Kyllian JAMES and Gael Charrier for the their work on the project.

