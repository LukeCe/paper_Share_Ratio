---
title: "Modeling the French presidential elections of 2022 with CoDa tools"
author:
  - Lukas Dargel
  - Christine Thomas-Agnan
format:
  html:
    theme: minty
    toc: true
    number-sections: true
    code-fold: true
    code-tools: true
    df-print: kable
    embed-resources: true
    standalone: true
    self-contained: true
execute:
  cache: true
  fig-show: "hold"
---

```{r setup}
#| warning: false
#| message: false
library("CoDaImpact")
library("compositions")
library("data.table")
library("here")
library("ggplot2")
library("kableExtra")
library("skimr")
library("zCompositions")


options(knitr.kable.NA = '',
        scipen = 9)

mun_elec2census <- readRDS(here("out/data/mun_elec2census.Rds")) # election data combined with the census
mun_elec <- readRDS(here("in/data/mun_elec.Rds")) # original election data 
```


The vignette illustrates results of the article from Dargel and Thomas-Agnan (2023).


# Introduction

We illustrate the use of CoDa tools to analyse the results of political elections based on the example of the French presidential elections of 2022.
Our main focus lays on model interpretation, which is why other issues such as the treatment of zeros are treated more briefly.


# Descriptive statistics

The study combine the official election results with census data.
  - [The original census data is available on the INSEE website](https://www.insee.fr/fr/statistiques/6543200#consulter)
  - [The official election results are provided by the French government and can be dowloaded here](https://www.data.gouv.fr/fr/datasets/election-presidentielle-des-10-et-24-avril-2022-resultats-definitifs-du-1er-tour/)
  

## Data overview 

Let us have a first look at the combined data set.

```{r}
skim(mun_elec2census)
```


## Compare losses due to preprocessing 


Let us compare the original voting data with the combined voting data to assess the losses and potential biases.

```{r}
# original election columns
elec_cols <- setdiff(names(mun_elec), c("ID_MUN", "NAME_MUN", "NAME_DEP"))
pct <- function(x) scales::percent(x,accuracy = .1)
summarize_elec <- function(dt) {
  
  dt <- data.table(
    MUN_COUNT = nrow(dt),
    DEP_COUNT = length(unique(dt$NAME_DEP)),
    dt[,lapply(.SD, sum), .SDcols = elec_cols]
  )
  
  
  dt[,EXPRESSED := NA]
  dt[,REGISTERED := sum(.SD), .SDcols = elec_cols]
  dt[,EXPRESSED := REGISTERED - ABSTENTIONS - BLANK - INVALID]
  
  show_dt <- data.table(t(dt),keep.rownames = TRUE)
  
  dont_use <- c("MUN_COUNT","DEP_COUNT")
  show_dt[!rn %in% dont_use,
          "% of REGISTERED" := pct(V1/dt[["REGISTERED"]])]
  
  dont_use <- c(dont_use, "ABSTENTIONS", "BLANK", "INVALID", "REGISTERED")
  show_dt[!rn %in% dont_use,
          "% of EXPRESSED" := pct(V1/dt[["EXPRESSED"]])]
  names(show_dt)[1:2] <- c("INDICATOR", "COUNT")
  show_dt
}  


elec_original <- summarize_elec(mun_elec)
elec_combined <- summarize_elec(mun_elec2census)
elec_combined <- cbind(LOSS = elec_original[["COUNT"]] - elec_combined[["COUNT"]], elec_combined[,-1])
elec_combined <- cbind("% LOSS" = pct(elec_combined[["LOSS"]]/elec_combined[["COUNT"]]), elec_combined)
kable(cbind(elec_original, elec_combined)) |> 
  kable_classic(full_width = F) |> 
  add_header_above(c(" " = 1, "Full election data" = 3, "Combined election data" = 5)) |> 
  pack_rows(group_label = "Units", 1,2,hline_after = TRUE) |> 
  pack_rows(group_label = "Not expressed", 3,5,hline_after = TRUE) |> 
  pack_rows(group_label = "Expressed", 6,17,hline_after = TRUE) |> 
  pack_rows(group_label = "Totals", 18,19,hline_after = TRUE) |> 
  column_spec(1, bold = T) 
```


## Check for problems with zeros


### In the vote data

We first check for zeros in the dependent variables.

```{r}
zero_summary <- function(dt) dt[,lapply(.SD, function(x) pct(sum(x==0)/.N))]
zero_summary(mun_elec2census[,..elec_cols])
```

One way to solve the problem is amalgamations.
We see that almost $98.5\%$ of observations are complete now.

```{r}
left_bloc <- c("ARTHAUD_Nathalie", "ROUSSEL_Fabien", "HIDALGO_Anne", "JADOT_Yannick", "POUTOU_Philippe")
right_bloc <- c("ZEMMOUR_Eric", "PECRESSE_Valerie", "LASSALLE_Jean", "DUPONT_AIGNAN_Nicolas")

VOTE <- cbind(
  mun_elec2census[,c("MACRON_Emmanuel", "LE_PEN_Marine", "MELENCHON_Jean_Luc")],
  LEFT = rowSums(mun_elec2census[,..left_bloc]),
  RIGHT = rowSums(mun_elec2census[,..right_bloc]),
  NON_VOTE = rowSums(mun_elec2census[,c("ABSTENTIONS", "INVALID","BLANK"),]))

zPatterns(
  VOTE,
  label="0",
  bar.labels = c(T,T),
  axis.labels = c(NA,NA))
```

`r zv <- sum(0 != rowSums(VOTE == 0))`
The remaining zeros are imputed.
Here take the simple road of adding 1 for to all lines with at least one zero.
Here we impute data in `r zv` cases with `r zv*ncol(VOTE)` additional "inscriptions".


```{r}
is_zero_row <- 0 != rowSums(VOTE == 0) 
VOTE_IMP <- VOTE + is_zero_row
cbind(
  sum(is_zero_row),
  sum(is_zero_row) * ncol(VOTE),
  sum(VOTE_IMP) - sum(VOTE))
```

#### Before and after

Let us check the impact of the imputation on the distribution of the data.
We see that our imputation leads an increase in the variance, but does not affect the average in a noticeable way.
This is expected because our imputation method replaces zeros (red bars in the graphic) with points close to the edge of the triangle, which are extreme values in the simplex sense.

```{r}
#| fig-show: "hold"

simplex_isodensity <- function(
  data,
  quantiles = c(0.5,1:9,9.5)/10,
  labels = names(cen),
  col1 = "black",
  col2 = "grey45",
  plot_data = TRUE) {
  
  # code adapted from:
  # Van den Boogaart and Tolosana-Delgado (2013), page 52
  
  stopifnot(ncol(data) == 3)
  cen <- mean(data)
  var <- var(data)
  if (plot_data) 
    plot(data, pch = ".", col = "grey85", labels = labels, mp = NULL, lenMissingTck = 0.02)
  plot(cen,pch=4, col = col1, labels = labels, add = plot_data)
  for (p in quantiles) {
    r = sqrt(qchisq(p=p,df=2))
    ellipses(cen,var,r, col=col2)
  }
}

opar <- par(mar=c(0,3,0,3), mfrow = c(1,2))
simplex_isodensity(acomp(VOTE_IMP[,1:3]), labels = c("Macron", "Le Pen", "Mélenchon"))
title(sub = "Imputed", outer = FALSE)
simplex_isodensity(acomp(VOTE[,1:3]), labels = c("Macron", "Le Pen", "Mélenchon"))
title(sub = "Original")
par(opar)
```

```{r}
#| fig-show: "hold"

opar <- par(mar=c(0,3,0,3), mfrow = c(1,2))
simplex_isodensity(acomp(VOTE_IMP[,-(1:3)]), labels = c("Left", "Right", "No vote"))
title(sub = "Imputed", outer = FALSE)
simplex_isodensity(acomp(VOTE[,-(1:3)]), labels = c("Left", "Right", "No vote"))
title(sub = "Original")
par(opar)
```



### In the professional categories (PC) data

The professional categories data directly comes from the French population census provided by the INSEE.
It categorizes the population above the age of 15 into one of eight groups.
The categories correspond to

  + `C19_POP15P_CS1`: Agriculteurs exploitants
  + `C19_POP15P_CS2`: Artisans, Commerçants, Chefs d'entreprise
  + `C19_POP15P_CS3`: Cadres et Professions intellectuelles supérieures
  + `C19_POP15P_CS4`: Professions intermédiaires
  + `C19_POP15P_CS5`: Employés
  + `C19_POP15P_CS6`: Ouvriers
  + `C19_POP15P_CS7`: Retraités
  + `C19_POP15P_CS8`: Autres sans activité professionnelle


```{r}
pc_cols <- names(mun_elec2census)
pc_cols <- pc_cols[grep("^C19_", pc_cols)]
zero_summary(mun_elec2census[,..pc_cols])
```

Since the number of municipalities having zero share of some of these categories is to large we proceed with an amalgamation of the eight original groups into four broader categories.
Using the new categorization about  $95%$ of the municipalities have are complete.

```{r}
PROFCAT <- cbind(
  "PC1" = mun_elec2census[,C19_POP15P_CS3 + C19_POP15P_CS4],
  "PC2" = mun_elec2census[,C19_POP15P_CS5 + C19_POP15P_CS6],
  "PC3" = mun_elec2census[,C19_POP15P_CS7],
  "PC4" = mun_elec2census[,C19_POP15P_CS1 + C19_POP15P_CS2 + C19_POP15P_CS8]
)

zPatterns(
  PROFCAT,
  label="0",
  bar.labels = c(T,T),
  axis.labels = c(NA,NA))
```

`r zv <- sum(0 != rowSums(PROFCAT == 0))`
We impute the data using the same strategy as before.
Here we impute data in `r zv` municipalities leading to `r zv*ncol(PROFCAT)` additional "inscriptions".

```{r}
is_zero_row <- 0 != rowSums(PROFCAT == 0) 
PROFCAT_IMP <- PROFCAT + is_zero_row
cbind(
  sum(is_zero_row),
  sum(is_zero_row) * ncol(PROFCAT),
  sum(PROFCAT_IMP) - sum(PROFCAT))
```

#### Before and after imputation

We have the same results as before, but the increase in variance appears more pronounced.

```{r}
#| fig-show: "hold"
opar <- par(mar=c(0,3,0,3), mfrow = c(1,2))
simplex_isodensity(acomp(PROFCAT_IMP[,(1:3)]))
title(sub = "Imputed", outer = FALSE)
simplex_isodensity(acomp(PROFCAT[,(1:3)]))
title(sub = "Original")
par(opar)
```

```{r}
#| fig-show: "hold"
opar <- par(mar=c(0,3,0,3), mfrow = c(1,2))
simplex_isodensity(acomp(PROFCAT_IMP[,(2:4)]))
title(sub = "Imputed", outer = FALSE)
simplex_isodensity(acomp(PROFCAT[,(2:4)]))
title(sub = "Original")
par(opar)
```


# Exploratory analysis


We defined the data set for our analysis.
Which is based on the imputed vote and professional categories (PC) data.


```{r}
mun2explore <- data.table(
  ID_MUN = mun_elec2census$ID_MUN,
  REGISTERED = rowSums(VOTE_IMP))
mun2explore <- cbind(mun2explore, VOTE_IMP, PROFCAT_IMP)
```


## Concentration

(Not yet ready)


## Heteroskedasticity


Since election data corresponds to aggregations of individual choices we should suspect heteroskedasticity.
The scatter plot below shows that that the share of "non votes" is directly impacted by the total number of voters.
Additionally, its volatility seems to decrease with the size of the municipality in terms number if voters.

```{r}
ggplot(mun2explore[REGISTERED < 300000,], aes(x = sqrt(REGISTERED), y = NON_VOTE/REGISTERED)) +
  # geom_boxplot(aes(x = REGISTERED_BINS, y = ABSTENTIONS/REGISTERED)) +
  geom_point() +
  geom_smooth() +
  theme_bw() +
  theme()
```

A similar pattern is observed for all vote variables.

```{r}
seq125 <- c(0, unlist(lapply(10^seq(10), "*", c(1,2,5))))
seqSqr <- seq(0,15)^2 * 1000 
mun2explore[,REGISTERED_BINS := cut(REGISTERED,c(seqSqr,Inf))]
mun2explore_long <- 
  melt(mun2explore,
       id.vars = c("ID_MUN","REGISTERED_BINS"),
       measure.vars = colnames(VOTE))

mun2explore_long[,value_rel := value/sum(value), by = "ID_MUN"]
ggplot(mun2explore_long, aes(x = REGISTERED_BINS, y = value_rel)) +
  geom_boxplot(outlier.size = .1) +
  facet_wrap("variable", ncol = 3) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90))

```


And for the PC variables as well.

```{r}
mun2explore_long2 <- 
  melt(mun2explore,
       id.vars = c("ID_MUN","REGISTERED_BINS"),
       measure.vars = colnames(PROFCAT))

mun2explore_long2[,value_rel := value/sum(value), by = "ID_MUN"]
ggplot(mun2explore_long2, aes(x = REGISTERED_BINS, y = value_rel)) +
  geom_boxplot(outlier.size = .1) +
  facet_wrap("variable", ncol = 2) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90))
```


##  Correlations


# Model for the share of "non votes"

```{r}
mun2model <- data.frame(
  ID_MUN = mun_elec2census$ID_MUN,
  REGISTERED = rowSums(as.matrix(VOTE_IMP)),
  REGISTERED_G = Reduce("*", lapply(VOTE_IMP, as.numeric)))
mun2model[["VOTE"]] <- acomp(VOTE_IMP)
mun2model[["PROFCAT"]] <- acomp(PROFCAT_IMP)

logit <- function(p) log(p/(p+1))
NV_model <- lm(
  logit(VOTE[,6]) ~  ilr(PROFCAT) + log(REGISTERED),
  data = mun2model,
  weights = REGISTERED)
summary(NV_model)
```


## Coefficients and Semi-elasticites

```{r}
clr_coefs <- matrix(ilr2clr(NV_model$coefficients[2:4]),nrow = 1)
barplot(clr_coefs, names.arg = colnames(PROFCAT))
```

## Variation scenarios

Let us investigate how the model react to changes when the PC composition changes in Paris.

```{r}
paris <- "75056"
paris <- mun2model[mun2model$ID_MUN == paris,,drop = FALSE]
paris$VOTE
paris$PROFCAT
```


### Changing in direction of first summit

```{r}
paris_pcseq1 <- CoDa_seq(
  comp_from = paris$PROFCAT,
  comp_to = c(1e10,1,1,1)*as.numeric(paris$PROFCAT),
  add_opposite = TRUE)

barplot(acomp(paris_pcseq1[,,drop=FALSE]))
```

This is a special direction that leaves the ratios between all other components constant.

```{r}
#| fig-show: "hold"
opar <- par(mfrow = c(1,2))
plot.acomp(paris_pcseq1[,-4])
plot.acomp(paris_pcseq1["0",-4, drop = FALSE], col = "red", add = TRUE, pch = "X")


plot.acomp(paris_pcseq1[,-1])
plot.acomp(paris_pcseq1["0",-1, drop = FALSE], col = "red", add = TRUE, pch = "X")
par(opar)
```

The changes appear linear in real space.

```{r}
paris_pcseq1_gg <- data.frame(paris_pcseq1)
colnames(paris_pcseq1_gg) <- paste0("PC", 1:4)
ggplot(paris_pcseq1_gg) +
  geom_vline(xintercept = paris$PROFCAT[[1]]) +
  geom_line(aes(x = PC1, y = PC1, col = "1", lty = "1"), lwd = .51) +
  geom_line(aes(x = PC1, y = PC2, col = "2", lty = "2"), lwd = .51) +
  geom_line(aes(x = PC1, y = PC3, col = "3", lty = "3"), lwd = .51) +
  geom_line(aes(x = PC1, y = PC4, col = "4", lty = "4"), lwd = .51) +
  geom_hline(yintercept = 0, col = "black") +
  geom_boxplot(
    data = data.frame(PC1 = mun2model$PROFCAT[,1]),
    mapping = aes(x = PC1, y = -.0625),
    varwidth = TRUE,
    size = .5,
    col = "red",
    alpha = .25,
    width = .05) +
  scale_x_continuous(labels = scales::percent) +
  scale_y_continuous(labels = scales::percent) +
  scale_color_manual(
    breaks = c("1","2", "3", "4"),
    values = c("Red", "Orange", "Dark Blue", "Yellow"),
    name = "PC") +
  scale_linetype_manual(
    breaks = c("1","2", "3", "4"),
    values = 1:4,
    name = "PC") +
  labs(x = "% PC 1", y = "% PC") +
  theme_bw()
```


### Changing in direction of the origin

An alternative linear change is the direction that connects the composition of Paris with the origin, that is the balanced composition.

```{r}
paris_pcseq2 <- CoDa_path(
  comp_direc = paris$PROFCAT,
  comp_from = paris$PROFCAT,
  add_opposite = TRUE,
  step_size = attr(paris_pcseq1,"step_size"))

barplot(acomp(paris_pcseq2[,,drop=FALSE]))
```

Here the paths in the simplex look more complex.

```{r}
#| fig-show: "hold"
opar <- par(mfrow = c(1,2))
plot.acomp(paris_pcseq2[,-4])
plot.acomp(paris_pcseq2["0",-4, drop = FALSE], col = "red", add = TRUE, pch = "X")

plot.acomp(paris_pcseq2[,-1])
plot.acomp(paris_pcseq2["0",-1, drop = FALSE], col = "red", add = TRUE, pch = "X")
par(opar)
```

Here we have non-linear changes in the euclidean sense.
We see that the lines cross in the origin and at the position of pairs their values equal as before.

```{r}

paris_pcseq2_gg <- data.frame(paris_pcseq2)
colnames(paris_pcseq2_gg) <- paste0("PC", 1:4)
ggplot(paris_pcseq2_gg) +
  geom_vline(xintercept = paris$PROFCAT[[1]]) +
  geom_vline(xintercept = 1/4, col = "grey55") +
  geom_line(aes(x = PC1, y = PC1, col = "1", lty = "1"), lwd = .51) +
  geom_line(aes(x = PC1, y = PC2, col = "2", lty = "2"), lwd = .51) +
  geom_line(aes(x = PC1, y = PC3, col = "3", lty = "3"), lwd = .51) +
  geom_line(aes(x = PC1, y = PC4, col = "4", lty = "4"), lwd = .51) +
  geom_hline(yintercept = 0, col = "black") +
  geom_boxplot(
    data = data.frame(PC1 = mun2model$PROFCAT[,1]),
    mapping = aes(x = PC1, y = -.0625),
    varwidth = TRUE,
    size = .5,
    col = "red",
    alpha = .25,
    width = .05) +
  scale_x_continuous(labels = scales::percent) +
  scale_y_continuous(labels = scales::percent) +
  scale_color_manual(
    breaks = c("1","2", "3", "4"),
    values = c("Red", "Orange", "Dark Blue", "Yellow"),
    name = "Professional\nCategory") +
  scale_linetype_manual(
    breaks = c("1","2", "3", "4"),
    values = 1:4,
    name = "Professional\nCategory") +
  labs(x = "% PC 1", y = "% PC") +
  theme_bw() +
  theme(axis.line.x = element_blank())
```


### Effects of these changes on the predicted shares

```{r}
```



### Dependence profiles for the whole dataset



# Model of the full compostion of votes

```{r}
VOTE_model <- lm(
  ilr(VOTE) ~  ilr(PROFCAT) + log(REGISTERED),
  data = mun2model,
  weights = REGISTERED)
summary(VOTE_model)
```


## Coefficients  and Elasticities

```{r}
clr_coefs <- (ilrBase(D = 4)) %*% as.matrix(ilr2clr(VOTE_model$coefficients[2:4,]))
colnames(clr_coefs) <- colnames(VOTE)
clr_coefs <- cbind(PROFCAT = colnames(PROFCAT), data.table(clr_coefs))
clr_coefs_gg <- melt(clr_coefs, id.var = "PROFCAT")

ggplot(clr_coefs_gg) +
  # geom_col(aes(y = value, group = variable, x = variable, fill = variable, col = variable),
  #          position = "dodge") +
  theme_bw() +
  coord_flip() +
  geom_hline(yintercept = 0) +
  geom_segment(aes(x=variable, xend=variable, y=0, yend=value, col = variable)) +
  geom_errorbar(aes(ymax=value*c(1.15),
                    ymin=value*c(.85),
                    x=variable,  col = variable)) +
  geom_point(aes(x=variable, y = value, col = variable)) +
  geom_boxplot(aes(y = value, x = "All")) +
  facet_wrap("PROFCAT") +
  theme(legend.position = "none")

# ggplot(clr_coefs_gg) +
#   geom_segment(aes(x=PROFCAT, xend=PROFCAT, y=0, yend=value)) +
#   geom_point(aes(x=PROFCAT, y = value)) +
#   # geom_col(aes(y = value, group = variable, x = PROFCAT, fill = variable, col = variable),
#            # position = "dodge") +
#   geom_boxplot(aes(y = value, x = "All")) +
#   theme_bw() +
#   facet_wrap("variable")
```


## Vriation scenarios



## Dependence profiles










# Acknowlegements {-}

This work emerged from a Statistical Consulting project class of the Master in D3S of TSE in cooperation with he Market Research agency BVA who motivated the topic.
The project was a great experience and we want to thank all participants.
This includes Oliver Henebelle and Alejandro Lara who advised the project from the business.
We also thank our four students, Claire LEBRUN, Malo Bert, Kyllian JAMES and Gael Charrier for the their work on the project.

